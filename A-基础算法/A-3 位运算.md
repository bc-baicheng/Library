# 位运算

## 四个算术位运算

### 1. 与（and / &）：两边有一边为 `0` 则结果为 `0` ；
### 2. 或（or / | ）：两边有一边为 `1` 则结果为 `1` ；
### 3. 非（not / ~）：`0` 的取反为 `1`，`1` 的取反为 `0`；
### 4. 异或（xor / ^）：不进位加法，两边一样为 `0`，不一样为 `1`.

##

## 位移运算

### 1. 左移：
- 在二进制表示下把数字同时向左移动，低位以0填充，高位越界后舍弃。

$$ 1 << n = 2^n , n << 1 = 2n $$

### 2. 算数右移：
- 在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。
  
$$ n >> 1 = \lfloor\frac{n}{2.0}\rfloor $$

- 算数右移等于除以2向下取整：(-3) >> 1 = -2，3 >> 1 = 1。

##

## 快速幂（luogu P1226）

### 求 $a$ 的 $b$ 次方对 $p$ 取模的值，其中 $1 ≤ a,b,p ≤ 10^9$

根据数学常识，每一个正整数可以唯一表示为若干指数不重复的 2 的次幂的和。也就是说，如果 b 在二进制表示下有 k 位，其中 $i(0 \leq i \lt k)$ 位的数字是 $c_i$，那么：

$$b = c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+...+c_02^0$$

于是：

$$ a^b=a^{c_{k-1}2^{k-1}}a^{c_{k-2}2^{k-2}}...a^{c_02^0} $$

因为 $k=\lceil\log_2{(b+1)}\rceil$ （其中 $\lceil\rceil$ 表示向上取整），所以上式乘积项的数量不多于 $\lceil\log_2{(b+1)}\rceil$ 个。又因为：

$$a^{2^i}={(a^{2^i-1})}^2$$

所以我们很容易通过 k 次推导求出每个乘积项，当 $c_i=i$ 时，把该乘积项累积到答案中。b&1 运算可以取出 b 在二进制表示下的最低位，而 b >> 1 运算可以舍去最低位，在递推的过程中将二者结合，就可以遍历 b 在二进制表示下的所有数位 $c_i$ 。整个算法的时间复杂度为 $O(\log_2 b)$ 。

```cpp
#define ll long long

ll power(ll a, ll b, ll p)
{
    ll ans = 1 % p;
    for( ; b; b >>= 1)
    {
        if(b & 1) ans = ans * a % p;
        a = a * a % p;
    }
    return ans;
}
```

在上面的代码片段中，我们通过 “右移（>>）” “与（&）” 运算的结合，遍历了 b 的二进制表示的下一位。在循坏到 $i$ 次时（从 0 开始计数），变量 a 中储存的是 $a^{2^i}$，若 b 该位为 1，则把此时的变量 a 累积到答案 ans 中。

##