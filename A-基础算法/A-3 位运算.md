# 位运算

## 四个算术位运算

### 1. 与（and / &）：两边有一边为 `0` 则结果为 `0` ；
### 2. 或（or / | ）：两边有一边为 `1` 则结果为 `1` ；
### 3. 非（not / ~）：`0` 的取反为 `1`，`1` 的取反为 `0`；
### 4. 异或（xor / ^）：不进位加法，两边一样为 `0`，不一样为 `1`.

##

## 位移运算

### 1. 左移：
- 在二进制表示下把数字同时向左移动，低位以0填充，高位越界后舍弃。

$$ 1 << n = 2^n , n << 1 = 2n $$

### 2. 算数右移：
- 在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。
  
$$ n >> 1 = \lfloor\frac{n}{2.0}\rfloor $$

- 算数右移等于除以2向下取整：(-3) >> 1 = -2，3 >> 1 = 1。

##

## 快速幂（luogu P1226）

### 求 $a$ 的 $b$ 次方对 $p$ 取模的值，其中 $1 ≤ a,b,p ≤ 10^9$

$\qquad$ 根据数学常识，每一个正整数可以唯一表示为若干指数不重复的 2 的次幂的和。也就是说，如果 b 在二进制表示下有 k 位，其中 $i(0 \leq i \lt k)$ 位的数字是 $c_i$，那么：

$$b = c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+...+c_02^0$$

$\qquad$ 于是：

$$ a^b=a^{c_{k-1} \ast 2^{k-1}} \ast a^{c_{k-2} \ast 2^{k-2}} \ast ... \ast a^{c_0 \ast 2^0} $$

$\qquad$ 因为 $k=\lceil\log_2{(b+1)}\rceil$ （其中 $\lceil\rceil$ 表示向上取整），所以上式乘积项的数量不多于 $\lceil\log_2{(b+1)}\rceil$ 个。又因为：

$$a^{2^i}={(a^{2^i-1})}^2$$

$\qquad$ 所以我们很容易通过 k 次推导求出每个乘积项，当 $c_i=i$ 时，把该乘积项累积到答案中。b&1 运算可以取出 b 在二进制表示下的最低位，而 b >> 1 运算可以舍去最低位，在递推的过程中将二者结合，就可以遍历 b 在二进制表示下的所有数位 $c_i$ 。整个算法的时间复杂度为 $O(\log_2 b)$ 。

```cpp
#define ll long long

ll power(ll a, ll b, ll p)
{
    ll ans = 1 % p;
    for( ; b; b >>= 1)
    {
        if(b & 1) ans = ans * a % p;
        a = a * a % p;
    }
    return ans;
}
```

$\qquad$ 在上面的代码片段中，我们通过 “右移（>>）” “与（&）” 运算的结合，遍历了 b 的二进制表示的下一位。在循坏到 $i$ 次时（从 0 开始计数），变量 a 中储存的是 $a^{2^i}$，若 b 该位为 1，则把此时的变量 a 累积到答案 ans 中。

##

## 64位整数乘法 （luogu P10446）

### 求 $a$ 乘 $b$ 对 $p$ 取模的值，其中 $1 \leq a,b,p \leq 10^{18}$ 。

$\qquad$ 类似于快速幂的思想，把整数 b 用二进制表示，即：

$$b = c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+...+c_02^0$$

$\qquad$ 那么：

$$ a \ast b = c_{k-1} \ast a \ast 2^{k-1} + c_{k-2} \ast a \ast 2^{k-2} + ...+ c_0 \ast a \ast 2^0 $$

$\qquad$ 因为 $a \ast 2^i = (a \ast 2^{i-1}) \ast 2$ 若已求出 $a \ast 2^{i-1} mod p$ ，则计算 $(a \ast 2^{i-1}) \ast 2 mod p$ 时，运算过程中每一步的结果都不超过 $2 \ast 10^{18}$ ，仍然在64位整数 long long 的表示范围之内，所以很容易通过 k 次递推求出每个乘积项。当 $c_i=1$ 时，把该乘积项累加到答案中即可。时间复杂度为 $O(\log_2b)$ 。

```cpp
#define ll long long

ll mul(ll a, ll b, ll p)
{
    ll ans = 0;
    for( ; b; b >>= 1)
    {
        if(b & 1) ans = (ans + a) % p;
        a = a * 2 % p;
    }
    return ans;
}
```

##

## 二进制状态压缩

$\qquad$ 二进制状态压缩，是指将一个长度位 $m$ 的 $bool$ 数组用一个 $m$ 位二进制整数表示并存储的方法。

利用下列位运算操作可以实现原 $bool$ 数组中对应下标元素的存取。

取出整数 $n$ 在二进制表示下的第 $k$ 位： $\quad (n >> k)$ & $1$

取出整数 $n$ 在二进制表示下的第 $0\sim k-1$ 位（后 $k$ 位）： $\quad n$ & $((1<<k)-1)$

把整数 $n$ 在二进制表示下的第k位取反： $\quad n$ ^ $(1<<k)$ 

对整数 $n$ 在二进制表示下的第 $k$ 位赋值 $1$ ： $\quad n$ | $(1<<k)$ 

对整数 $n$ 在二进制表示下的第 $k$ 位赋值 $0$ ： $\quad n$ & $(\sim (1<<k))$ 

##

## 起床困难综合症（luogu P2114）

### $\qquad$ 一个 boss 的防御战线由 n 扇防御门组成，其中第 i 扇防御门的属性包括一个运算 $op_i$ 和一个参数 $t_i$ ，运算一定是 $OR$ 、 $XOR$ 、 $AND$ 中的一种，参数是非负整数。若在未通过这扇防御门时攻击力为 x，则通过这扇防御门后攻击力将变为 $x$ $op_i$ $t_i$ 。最终 boss 受到的伤害为玩家的初始攻击力 $x_0$ 依次经过所有 n 扇防御门后得到的攻击力。由于水平有限，玩家的初始攻击力只能为 $[0,m]$ 之间的一个整数。玩家希望通过选择合适的初始攻击力，使他的攻击能造成最大的伤害，求这个伤害数值。
### $\qquad$ 数据范围： $n \leq 10^5, m, t_i \leq 10^9$ 。

$\qquad$ 本题是让我们选择 $[0,m]$ 之间的一个整数 $x_0$ ，经过给定的 $n$ 次位运算，使结果 $ans$ 最大。

$\qquad$ 位运算的主要特点之一是`在二进制表示下不进位`。正因如此，在 $x_0$ 可以任意选择的情况下，参与位运算的各个位 $(bit)$ 之间是独立无关的。换言之，对于任意的 $k(0\leq k\lt30)$ ,“ $ans$ 的第 $k$ 位是几” 只与 “ $x_0$ 的第 $k$ 位是几” 有关，与其他位无关。所以我们可以从高位到低位，依次考虑 $x_0$ 的每一位填 0 还是填 1。

$\qquad$ $x_0$ 的第 $k$ 位应该填 1，当且仅当同时满足以下两个条件：

$\qquad$ 1. 已经填好的更高位构成的数值加上 $1<<k$ 以后不超过 $m$

$\qquad$ 2. 用每个参数的第 $k$ 位参与位运算。若初值为 1，则 $n$ 次位运算后结果为 1；若初值为 0，则 $n$ 次位运算后结果为 0

$\qquad$ 如果不满足上述条件，要么填 1 会超过 $m$ 的范围，要么填 1 不如填 0 更优。这种情况下令 $x_0$ 的第 $k$ 位为 0 显然更好。确定 $x_0$ 的每一位以后，自然可以得到 $ans$ 的值。

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;
    vector<pair<string, int>> a(n+1);
    for(int i = 1; i <= n; i ++ )
    {
        string str;
        int x;
        cin >> str >> x;
        a[i] = {str, x};
    }
    int val = 0, ans = 0;
    for(int bit = 29; bit >= 0; bit-- )
    {
        auto calc = [&](int bit, int now) -> int
        {
            for(int i = 1; i <= n; i ++ )
            {
                int x = a[i].second >> bit & 1;
                if(a[i].first == "AND") now &= x;
                else if(a[i].first == "OR") now |= x;
                else now ^= x;
            }
            return now;
        };
        int res0 = calc(bit, 0);
        int res1 = calc(bit, 1);
        if(val + (1 << bit) <= m && res0 < res1)
            val += 1 << bit, ans += res1 << bit;
        else ans += res0 << bit;
    }
    cout << ans << endl;
}
```
### ps：一些运算符优先级从高到低的顺序为：

$$ 加减（+,-）、移位（>>,<<）、比较大小（>,<,==,!=）、 $$

$$ 位与（and）、异或（xor）、位或（or） $$

##