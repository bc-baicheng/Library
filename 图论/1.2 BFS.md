# BFS（广度优先搜索）

## 摘要

- `广度优先搜索` 是最简单的图搜索算法之一，也是许多重要的图算法的原型。如：`Prim` 的最小生成树算法，以及 `Dijkstra` 的单源最短路算法。

- `广度优先搜索` 可以用于计算从根结点 `s` 到每个可到达的结点的 `最短距离`，同时生成一颗 `广度优先搜索树`。

- `广度优先搜索` 算法利用 `队列` 来实现，时间复杂度为 `O(n + m)`。

## 过程

- 指定一个结点为`根结点`，而后`逐层扩展`，`逐层访问`。

- 在执行广度优先搜索的过程中将构建出一颗广度优先树：
  
  1. 一开始，该树仅有根结点 `s`.
  2. 在扫描已发现结点 `u` （或根节点 `s`）时，每触碰到一个 `第一次发现` 的结点 `v` 时，就将 `v` 以及边 `(u, v)` 同时加入这颗树中。

- 在广度优先树中，我们称结点 `u` 为结点 `v` 的 `前驱` 或 `父结点`，由于每个结点至多被发现一次，它只有一个夫结点。

- 广度优先树中的祖先和后代关系皆以相对于根结点 `s` 的位置来定义：如果结点 `u` 是从根结点 `s` 到结点 `v` 的简单路径上的一个结点，则结点 `u` 是结点 `v` 的祖先， 结点 `v` 是结点 `u` 的后代。

## 实现

- 广搜是通过 `队列` 实现的，用 `queue` 创建一个队列。

- 广搜的过程，通过队列来维护序列的 `状态空间`，入队就排队等待，出队就扩展后代结点入队。

- 初始化：利用邻接链表存图，`e[x]` 存结点 `x` 的邻点，`vis[x]` 标记 `x` 是否被搜索过，`q` 存入队的结点序列。

```cpp
//初始化
vector<int> e[N];
bool vis[N];
queue<int> q;

//bfs（广度优先搜索）
void bfs()
{
    vis[1] = true; q.push(1); //处理根结点
    
    while(q.size()) //如果队列不空则说明还没搜索完，继续搜索
    {
        int x = q.front(); q.pop(); //取出队头结点
        //printf("%d出队\n", x);
        for(int y : e[x]) //遍历结点 x 的子结点
        {
            if(vis[y]) continue; //如果这个结点已经搜索过了就跳过

            vis[y] = true; //标记结点 y 已经被搜过
            //printf("%d入队\n", y);
            q.push(y); //让结点 y 入队等待
        }
    }
}

//根据题意，可以在深搜的两次结点碰撞中进行操作：出队，入队。即 printf 所代表部分。
```

## 性质

- 在队列 `q` 中的结点关于层次满足 `两段性` 和 `单调性`

  1. `两段性` ：在队列中只会出现父子辈的结点，因为队列的扩展是在对结点的搜索时进行的，而当开始搜索父辈结点时，爷辈结点已经全部出队，因此不会出现三世同堂的现象。
  2. `单调性` ：队列中的结点辈分是单调递减的，不会出现子辈结点后排列父辈结点的现象。 